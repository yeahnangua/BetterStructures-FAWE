package com.magmaguy.betterstructures.util;

import org.bukkit.Chunk;
import org.bukkit.Material;
import org.bukkit.World;

/**
 * Utility class for validating chunk generation state.
 * Provides compatibility checks for async world generators like Terra + FAWE,
 * where chunks may be loaded but not yet fully populated with terrain data.
 */
public class ChunkValidationUtil {

    private ChunkValidationUtil() {
        // Utility class - no instantiation
    }

    /**
     * Checks whether a chunk has been fully generated by sampling multiple positions
     * to detect empty or partially generated chunks.
     *
     * @param chunk the chunk to validate
     * @return true if the chunk appears fully generated, false if null, unloaded, or incomplete
     */
    public static boolean isChunkFullyGenerated(Chunk chunk) {
        return getChunkGenerationFailureReason(chunk) == null;
    }

    /**
     * Returns a detailed failure reason when a chunk is considered not fully generated.
     * Returns null when the chunk passes validation.
     *
     * @param chunk the chunk to validate
     * @return null if valid; otherwise a short reason string for diagnostics
     */
    public static String getChunkGenerationFailureReason(Chunk chunk) {
        if (chunk == null) return "chunk_null";
        if (!chunk.isLoaded()) return "chunk_unloaded";

        try {
            World world = chunk.getWorld();
            boolean isEnd = world.getEnvironment() == World.Environment.THE_END;

            // End islands naturally contain huge air spans; only require the chunk to be actually generated.
            boolean generated = true;
            try {
                generated = chunk.isGenerated();
            } catch (NoSuchMethodError ignored) {
                // Older API versions may not expose isGenerated; keep legacy heuristic behavior.
            }
            if (!generated) {
                return "chunk_not_generated,env=" + world.getEnvironment();
            }
            if (isEnd) {
                return null;
            }

            int baseX = chunk.getX() << 4;
            int baseZ = chunk.getZ() << 4;

            int[][] offsets = new int[][]{
                    {0, 7},
                    {7, 0},
                    {15, 7},
                    {7, 15}
            };

            int airOnlyThreshold = 3;
            int voidAirThreshold = 2;

            int airOnlyColumns = 0;
            int voidAirCount = 0;
            int minHeight = world.getMinHeight();
            int checkY = (world.getMaxHeight() + minHeight) / 2;

            for (int[] offset : offsets) {
                int x = baseX + offset[0];
                int z = baseZ + offset[1];
                int highestY = world.getHighestBlockYAt(x, z);

                if (highestY <= minHeight) {
                    airOnlyColumns++;
                }

                if (world.getBlockAt(x, checkY, z).getType() == Material.VOID_AIR) {
                    voidAirCount++;
                }
            }

            if (airOnlyColumns >= airOnlyThreshold || voidAirCount >= voidAirThreshold) {
                return "air_only_columns=" + airOnlyColumns
                        + ",void_air_count=" + voidAirCount
                        + ",thresholds=air_only>=" + airOnlyThreshold + "|void_air>=" + voidAirThreshold
                        + ",sample_count=" + offsets.length
                        + ",env=" + world.getEnvironment()
                        + ",check_y=" + checkY
                        + ",min_y=" + minHeight;
            }

            return null;
        } catch (Exception e) {
            // Don't block structure placement on validation errors
            return null;
        }
    }

    /**
     * Checks if a chunk has reached at least BORDER load level.
     * BORDER/TICKING/ENTITY_TICKING are treated as ready for scanning.
     *
     * @param chunk the chunk to check
     * @return true if the chunk is at least BORDER level, false otherwise
     */
    public static boolean isChunkFullyReady(Chunk chunk) {
        if (chunk == null || !chunk.isLoaded()) return false;

        try {
            Chunk.LoadLevel loadLevel = chunk.getLoadLevel();
            return loadLevel == Chunk.LoadLevel.BORDER
                    || loadLevel == Chunk.LoadLevel.TICKING
                    || loadLevel == Chunk.LoadLevel.ENTITY_TICKING;
        } catch (NoSuchMethodError | NoClassDefFoundError e) {
            // Fallback for non-Paper servers: use basic generation check
            return isChunkFullyGenerated(chunk);
        }
    }

}
