package com.magmaguy.betterstructures.util;

import com.magmaguy.betterstructures.config.DefaultConfig;
import com.magmaguy.magmacore.util.Logger;
import org.bukkit.Chunk;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;

import java.util.HashSet;
import java.util.Set;

/**
 * Utility class for validating chunk generation state.
 * Provides compatibility checks for async world generators like Terra + FAWE,
 * where chunks may be loaded but not yet fully populated with terrain data.
 */
public class ChunkValidationUtil {

    private ChunkValidationUtil() {
        // Utility class - no instantiation
    }

    /**
     * Checks whether a chunk has been fully generated by sampling multiple positions
     * to detect empty or partially generated chunks.
     *
     * @param chunk the chunk to validate
     * @return true if the chunk appears fully generated, false if null, unloaded, or incomplete
     */
    public static boolean isChunkFullyGenerated(Chunk chunk) {
        if (chunk == null || !chunk.isLoaded()) return false;

        try {
            World world = chunk.getWorld();
            int baseX = chunk.getX() << 4;
            int baseZ = chunk.getZ() << 4;

            // Sample 4 positions: center and edges
            int[][] offsets = {
                    {0, 7},
                    {7, 0},
                    {15, 7},
                    {7, 15}
            };

            int airOnlyColumns = 0;
            int voidAirCount = 0;

            for (int[] offset : offsets) {
                int x = baseX + offset[0];
                int z = baseZ + offset[1];
                int highestY = world.getHighestBlockYAt(x, z);

                if (highestY <= world.getMinHeight()) {
                    airOnlyColumns++;
                }

                // Use sea level or mid-point as reference height (adapts to different world types)
                int checkY = (world.getMaxHeight() + world.getMinHeight()) / 2;
                if (world.getBlockAt(x, checkY, z).getType() == Material.VOID_AIR) {
                    voidAirCount++;
                }
            }

            if (airOnlyColumns >= 3 || voidAirCount >= 2) {
                return false;
            }

            return true;
        } catch (Exception e) {
            // Don't block structure placement on validation errors
            return true;
        }
    }

    /**
     * Validates that all chunks within a block coordinate range are loaded and fully generated.
     * Respects the validateChunkBeforePaste config option; if disabled, always returns true.
     *
     * @param world the world to check in
     * @param minX  minimum block X coordinate
     * @param minZ  minimum block Z coordinate
     * @param maxX  maximum block X coordinate
     * @param maxZ  maximum block Z coordinate
     * @return true if all chunks in the range are ready, false otherwise
     */
    public static boolean areChunksReadyForStructure(World world, int minX, int minZ, int maxX, int maxZ) {
        if (!DefaultConfig.isValidateChunkBeforePaste()) return true;

        int minChunkX = minX >> 4;
        int minChunkZ = minZ >> 4;
        int maxChunkX = maxX >> 4;
        int maxChunkZ = maxZ >> 4;

        for (int cx = minChunkX; cx <= maxChunkX; cx++) {
            for (int cz = minChunkZ; cz <= maxChunkZ; cz++) {
                if (!world.isChunkLoaded(cx, cz)) {
                    return false;
                }
                if (!isChunkFullyGenerated(world.getChunkAt(cx, cz))) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Calculates the set of chunk coordinates required for a structure at the given location.
     * Each entry is a string in the format "cx,cz".
     *
     * @param location the origin location of the structure
     * @param width    the width of the structure in blocks (X axis)
     * @param depth    the depth of the structure in blocks (Z axis)
     * @return a set of chunk coordinate strings covering the structure footprint
     */
    public static Set<String> getRequiredChunks(Location location, int width, int depth) {
        Set<String> chunks = new HashSet<>();

        int minChunkX = location.getBlockX() >> 4;
        int minChunkZ = location.getBlockZ() >> 4;
        int maxChunkX = (location.getBlockX() + width) >> 4;
        int maxChunkZ = (location.getBlockZ() + depth) >> 4;

        for (int cx = minChunkX; cx <= maxChunkX; cx++) {
            for (int cz = minChunkZ; cz <= maxChunkZ; cz++) {
                chunks.add(cx + "," + cz);
            }
        }

        return chunks;
    }
}
